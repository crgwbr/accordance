{"version":3,"file":"queue.js","sourceRoot":"","sources":["../../src/utils/queue.ts"],"names":[],"mappings":";;;AAAA,6BAA8B;AAE9B,+BAAkC;AAYlC,MAAa,SAAS;IAYlB,YAAY,OAAmB;QAX/B;;WAEG;QACK,WAAM,GAAsB,EAAE,CAAC;QASnC,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;IAC3B,CAAC;IAED;;OAEG;IACH,KAAK,CACD,MAAyB,EACzB,MAAc,EACd,SAAiB,EACjB,QAAgB;QAEhB,gGAAgG;QAChG,mCAAmC;QACnC,MAAM,GAAG,GAAG,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;QACnC,MAAM,QAAQ,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,EAAE;YACtC,OAAO,CAAC,CAAC,SAAS,KAAK,GAAG,IAAI,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC,SAAS,EAAE,GAAG,CAAC,CAAC;QACxE,CAAC,CAAC,CAAC;QACH,IAAI,QAAQ,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;YACtB,OAAO;QACX,CAAC;QAED,sFAAsF;QACtF,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,EAAE;YACnC,OAAO,CAAC,IAAI,CAAC,cAAc,CAAC,GAAG,EAAE,CAAC,CAAC,SAAS,CAAC,CAAC;QAClD,CAAC,CAAC,CAAC;QAEH,+DAA+D;QAC/D,IAAI,IAAI,CAAC,MAAM,CAAC,MAAM,GAAG,EAAE,EAAE,CAAC;YAC1B,MAAM,GAAG,GAAG,GAAG,MAAM,CAAC,WAAW,EAAE,KAAK,SAAS,IAAI,QAAQ,EAAE,CAAC;YAChE,OAAO,CAAC,GAAG,CAAC,IAAA,eAAS,EAAC,GAAG,CAAC,CAAC,CAAC;YAC5B,IAAI,CAAC,MAAM,GAAG;gBACV;oBACI,MAAM,EAAE,MAAM;oBACd,MAAM,EAAE,MAAM;oBACd,SAAS,EAAE,UAAU;oBACrB,SAAS,EAAE,GAAG;iBACjB;aACJ,CAAC;YACF,IAAI,CAAC,OAAO,EAAE,CAAC;QACnB,CAAC;QAED,iCAAiC;QACjC,OAAO,CAAC,GAAG,CACP,IAAA,eAAS,EACL,mBAAmB,SAAS,OAAO,QAAQ,OAAO,MAAM,EAAE,CAC7D,CACJ,CAAC;QACF,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC;YACb,MAAM,EAAE,MAAM;YACd,MAAM,EAAE,MAAM;YACd,SAAS,EAAE,SAAS;YACpB,SAAS,EAAE,GAAG;SACjB,CAAC,CAAC;QACH,IAAI,CAAC,OAAO,EAAE,CAAC;IACnB,CAAC;IAED;;OAEG;IACH,OAAO;QACH,OAAO,IAAI,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC;IAC/B,CAAC;IAED;;OAEG;IACH,IAAI;QACA,OAAO,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC;IAC7B,CAAC;IAEO,cAAc,CAAC,MAAc,EAAE,KAAa;QAChD,OAAO,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;IAC5D,CAAC;CACJ;AAvFD,8BAuFC","sourcesContent":["import path = require(\"path\");\nimport { IAccordanceConfig } from \"./config\";\nimport { makeGreen } from \"./cli\";\n\n/**\n * Interface of an entry in the unison sync queue\n */\nexport interface ISyncQueueEntry {\n    config: IAccordanceConfig;\n    source: string;\n    eventType: string;\n    directory: string;\n}\n\nexport class SyncQueue {\n    /**\n     * Queue of directories that need sync'd. Will be processed in FIFO order.\n     */\n    private _queue: ISyncQueueEntry[] = [];\n\n    /**\n     * Callback function to be run after an item is added to the queue\n     * @type {[type]}\n     */\n    private readonly onQueue: () => void;\n\n    constructor(onQueue: () => void) {\n        this.onQueue = onQueue;\n    }\n\n    /**\n     * Add a path to the sync queue\n     */\n    queue(\n        config: IAccordanceConfig,\n        source: string,\n        eventType: string,\n        filePath: string,\n    ) {\n        // If this directory exists in the queue already, OR if it's a subdirectory of something already\n        // in the queue, don't do anything.\n        const dir = path.dirname(filePath);\n        const existing = this._queue.filter((e) => {\n            return e.directory === dir || this.isSubDirectory(e.directory, dir);\n        });\n        if (existing.length > 0) {\n            return;\n        }\n\n        // If any subdirectories of the new directory already exist in the queue, remove them.\n        this._queue = this._queue.filter((e) => {\n            return !this.isSubDirectory(dir, e.directory);\n        });\n\n        // If the sync queue if getting huge, wipe it a sync everything\n        if (this._queue.length > 50) {\n            const msg = `${source.toUpperCase()}: ${eventType} ${filePath}`;\n            console.log(makeGreen(msg));\n            this._queue = [\n                {\n                    config: config,\n                    source: source,\n                    eventType: \"overflow\",\n                    directory: \".\",\n                },\n            ];\n            this.onQueue();\n        }\n\n        // Otherwise, just queue the sync\n        console.log(\n            makeGreen(\n                `QUEUE: Detected ${eventType} to ${filePath} on ${source}`,\n            ),\n        );\n        this._queue.push({\n            config: config,\n            source: source,\n            eventType: eventType,\n            directory: dir,\n        });\n        this.onQueue();\n    }\n\n    /**\n     * Dequeue an entry from the sync queue\n     */\n    dequeue() {\n        return this._queue.shift();\n    }\n\n    /**\n     * Get the size of the sync queue\n     */\n    size() {\n        return this.queue.length;\n    }\n\n    private isSubDirectory(parent: string, child: string) {\n        return path.relative(child, parent).indexOf(\"..\") === 0;\n    }\n}\n"]}